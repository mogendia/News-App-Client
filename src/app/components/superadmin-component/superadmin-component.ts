import { Component, OnDestroy, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { LiveService } from '../../services/Live.service';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-superadmin',
  imports: [CommonModule, FormsModule],
  templateUrl: './superadmin-component.html',
  styleUrl: './superadmin-component.scss'
})
export class SuperadminComponent implements OnInit, OnDestroy {
  streamTitle: string = '';
  isLive: boolean = false;
  userCount: number = 0;
  messages: { user: string; message: string }[] = [];
  chatMessage: string = '';
  private peerConnections: Map<string, RTCPeerConnection> = new Map();
  private stream: MediaStream | null = null;
  private subscriptions: Subscription = new Subscription();

  constructor(private liveService: LiveService) {}

  ngOnInit() {
    this.liveService.startConnection();

    // Subscribe to live status changes
    this.subscriptions.add(
      this.liveService.isLive$.subscribe(isLive => {
        this.isLive = isLive;
        // If stream ends unexpectedly, stop local broadcast
        if (!isLive && this.stream) {
          this.stopBroadcast();
        }
      })
    );

    // Subscribe to stream title changes
    this.subscriptions.add(
      this.liveService.streamTitle$.subscribe(title => {
        this.streamTitle = title;
      })
    );

    // Subscribe to user count changes
    this.subscriptions.add(
      this.liveService.userCount$.subscribe(count => {
        this.userCount = count;
      })
    );

    // Subscribe to incoming chat messages
    this.subscriptions.add(
      this.liveService.message$.subscribe(msg => {
        this.messages.push(msg);
      })
    );

    // Handle answers received from viewers
    this.subscriptions.add(
      this.liveService.answerReceived$.subscribe(async ({ viewerId, sdp }) => {
        console.log(`Received answer from viewer ${viewerId}`);
        const pc = this.peerConnections.get(viewerId);
        if (pc) {
          try {
            await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp }));
            console.log(`Set remote description (answer) for viewer ${viewerId}`);
          } catch (error) {
            console.error(`Error setting remote description (answer) for viewer ${viewerId}:`, error);
          }
        } else {
          console.warn(`Peer connection not found for viewer ${viewerId} when receiving answer.`);
        }
      })
    );

    // Handle ICE candidates received from viewers
    this.subscriptions.add(
      this.liveService.candidateReceived$.subscribe(async ({ fromId, candidate }) => {
        console.log(`Received candidate from viewer ${fromId}`);
        const pc = this.peerConnections.get(fromId);
        if (pc) {
          try {
            await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(candidate)));
            console.log(`Added ICE candidate for viewer ${fromId}`);
          } catch (error) {
            console.error(`Error adding ICE candidate for viewer ${fromId}:`, error);
          }
        } else {
          console.warn(`Peer connection not found for viewer ${fromId} when receiving candidate.`);
        }
      })
    );

    // This listener should be set up once to handle new viewer connections
    this.liveService.connection.on('ReceiveViewerId', async (viewerId: string) => {
      console.log('Admin received new viewerId:', viewerId);
      if (this.isLive && this.stream && !this.peerConnections.has(viewerId)) {
        console.log(`Setting up new peer connection for viewer: ${viewerId}`);
        const pc = new RTCPeerConnection(this.liveService.rtcConfiguration);
        this.peerConnections.set(viewerId, pc);

        // Add the local stream tracks to the peer connection
        this.stream.getTracks().forEach(track => pc.addTrack(track, this.stream!));

        // Handle ICE candidates generated by the admin's peer connection
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            console.log(`Sending ICE candidate to viewer ${viewerId}`);
            this.liveService.sendCandidate(viewerId, JSON.stringify(event.candidate));
          }
        };

        // Create and send the offer to the new viewer
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          if (offer.sdp) {
            console.log(`Sending SDP offer to viewer: ${viewerId}`);
            this.liveService.sendOffer(viewerId, offer.sdp);
          } else {
            console.error('Offer SDP is undefined for viewer:', viewerId);
          }
        } catch (error) {
          console.error(`Error creating/sending offer to viewer ${viewerId}:`, error);
        }
      } else if (this.peerConnections.has(viewerId)) {
        console.log(`Peer connection already exists for viewer: ${viewerId}. Skipping setup.`);
      }
    });
  }

  async startBroadcast() {
    try {
      // Request access to user's media devices
      this.stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      const videoElement = document.querySelector('video') as HTMLVideoElement;
      if (videoElement) {
        videoElement.srcObject = this.stream;
      } else {
        console.error('Video element not found for broadcast.');
        return;
      }

      // Notify SignalR Hub that the stream has started
      await this.liveService.startLive(this.streamTitle || 'Live Stream');
      console.log('Broadcast started successfully.');

    } catch (err) {
      console.error('Error starting broadcast:', err);
    }
  }

  stopBroadcast() {
    // Stop all tracks in the local stream
    this.stream?.getTracks().forEach(track => track.stop());
    this.stream = null;

    // Close all active peer connections
    this.peerConnections.forEach(pc => {
      pc.close();
      console.log('Closed peer connection.');
    });
    this.peerConnections.clear();

    // Notify SignalR Hub that the stream has stopped
    this.liveService.stopLive();
    console.log('Broadcast stopped.');
  }

  sendMessage() {
    if (this.chatMessage.trim()) {
      this.liveService.sendMessage('Superadmin', this.chatMessage);
      this.chatMessage = '';
    }
  }

  ngOnDestroy() {
    this.stopBroadcast();
    this.liveService.stopConnection();
    this.subscriptions.unsubscribe();
  }
}
