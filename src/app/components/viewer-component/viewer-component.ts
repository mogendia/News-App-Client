import { Component, OnDestroy, OnInit } from '@angular/core';
import { LiveService } from '../../services/Live.service';
import { Subscription } from 'rxjs';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-viewer-component',
  imports: [CommonModule, FormsModule],
  templateUrl: './viewer-component.html',
  styleUrl: './viewer-component.scss'
})
export class ViewerComponent implements OnInit, OnDestroy {
  streamTitle: string = '';
  isLive: boolean = false;
  messages: { user: string; message: string }[] = [];
  chatMessage: string = '';
  private peerConnection: RTCPeerConnection | null = null;
  private subscriptions: Subscription = new Subscription();

  constructor(private liveService: LiveService) {}

  ngOnInit() {
    this.liveService.startConnection();

    // Subscribe to live status changes from the service
    this.subscriptions.add(
      this.liveService.isLive$.subscribe(isLive => {
        console.log('isLive updated:', isLive);
        this.isLive = isLive;
        if (isLive) {
          this.startWatching();
        } else {
          // If stream goes offline, close peer connection
          this.peerConnection?.close();
          this.peerConnection = null;
          console.log('Live stream ended, closing peer connection.');
        }
      })
    );

    // Subscribe to stream title changes
    this.subscriptions.add(
      this.liveService.streamTitle$.subscribe(title => {
        this.streamTitle = title;
      })
    );

    // Subscribe to incoming chat messages
    this.subscriptions.add(
      this.liveService.message$.subscribe(msg => {
        this.messages.push(msg);
      })
    );

    // Initial check for live status and periodic checks
    this.checkLiveStatus();
    setInterval(() => this.checkLiveStatus(), 5000); // Check every 5 seconds
  }

  // Method to check the current live status from the hub
  async checkLiveStatus() {
    try {
      await this.liveService.ensureConnection();
      const isLive = await this.liveService.connection.invoke('IsLive');
      console.log('IsLive check from hub:', isLive);
      this.isLive = isLive; // Update local state based on hub's response
      if (isLive && !this.peerConnection) { // Only start watching if live and not already watching
        this.startWatching();
      } else if (!isLive && this.peerConnection) { // If not live but still connected, close
        this.peerConnection.close();
        this.peerConnection = null;
      }
    } catch (err) {
      console.error('Error checking live status:', err);
      this.isLive = false; // Assume not live if there's an error
    }
  }

  async startWatching() {
    if (this.peerConnection) {
      console.log('Already watching, skipping startWatching.');
      return;
    }

    try {
      this.peerConnection = new RTCPeerConnection(this.liveService.rtcConfiguration);
      console.log('New RTCPeerConnection created for viewer.');

      // Handle ICE candidates generated by the viewer's peer connection
      this.peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log('Sending ICE candidate to admin.');
          this.liveService.sendCandidateToAdmin(JSON.stringify(event.candidate));
        }
      };

      // Handle incoming media tracks from the admin
      this.peerConnection.ontrack = (event) => {
        console.log('Received remote track from admin.');
        const videoElement = document.querySelector('video') as HTMLVideoElement;
        if (videoElement) {
          videoElement.srcObject = event.streams[0];
        } else {
          console.error('Video element not found for viewer.');
        }
      };

      // Listener for SDP offers from the admin
      this.liveService.connection.on('ReceiveOffer', async (sdp: string) => {
        console.log('Received offer SDP from admin:', sdp);
        if (this.peerConnection) {
          try {
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp }));
            console.log('Set remote description (offer).');

            // Create and send the answer back to the admin
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);
            if (answer.sdp) {
              console.log('Sending SDP answer to admin.');
              this.liveService.sendAnswerToAdmin(answer.sdp);
            } else {
              console.error('Answer SDP is undefined.');
            }
          } catch (error) {
            console.error('Error processing offer or sending answer:', error);
          }
        }
      });

      // Handle ICE candidates received from the admin
      this.subscriptions.add(
        this.liveService.candidateReceivedFromAdmin$.subscribe(async candidate => {
          if (this.peerConnection) {
            try {
              await this.peerConnection.addIceCandidate(new RTCIceCandidate(JSON.parse(candidate)));
              console.log('Added ICE candidate from admin.');
            } catch (error) {
              console.error('Error adding ICE candidate from admin:', error);
            }
          }
        })
      );

      // Request viewer ID from the hub (this will trigger the admin to send an offer)
      await this.liveService.sendViewerId();
      console.log('Requested viewerId from hub.');

    } catch (err) {
      console.error('Error starting viewer:', err);
      this.peerConnection?.close();
      this.peerConnection = null;
    }
  }

  sendMessage() {
    if (this.chatMessage.trim()) {
      this.liveService.sendMessage('Viewer', this.chatMessage);
      this.chatMessage = '';
    }
  }

  ngOnDestroy() {
    this.peerConnection?.close();
    this.peerConnection = null;
    this.liveService.stopConnection();
    this.subscriptions.unsubscribe();
  }
}
